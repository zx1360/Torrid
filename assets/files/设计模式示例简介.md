# 设计模式代码示例集合

本文档汇总了创建型、结构型和行为型三大类设计模式的 Java 代码示例，每个示例都包含实际使用场景和完整实现。

## 一、创建型模式

创建型模式专注于对象创建的机制，帮助我们灵活地创建对象而无需暴露具体的创建逻辑。

### 1. 单例模式（Singleton）

**使用场景**：需要确保一个类只有一个实例，例如日志工具、配置管理器、线程池等。

```java
public class Logger {
    // 私有静态实例，使用volatile确保多线程下的可见性
    private static volatile Logger instance;
    
    // 私有构造函数，防止外部实例化
    private Logger() {
        // 防止通过反射创建实例
        if (instance != null) {
            throw new RuntimeException("请使用getInstance()方法获取实例");
        }
    }
    
    // 双重检查锁定，确保线程安全且高效
    public static Logger getInstance() {
        if (instance == null) {
            synchronized (Logger.class) {
                if (instance == null) {
                    instance = new Logger();
                }
            }
        }
        return instance;
    }
    
    // 日志方法
    public void log(String message) {
        System.out.println("[" + System.currentTimeMillis() + "] " + message);
    }
}

// 使用示例
class SingletonDemo {
    public static void main(String[] args) {
        // 获取日志实例
        Logger logger1 = Logger.getInstance();
        Logger logger2 = Logger.getInstance();
        
        // 验证是否为同一实例
        System.out.println(logger1 == logger2); // 输出true
        
        logger1.log("应用程序启动");
        logger2.log("用户登录成功");
    }
}
```

### 2. 简单工厂模式（Simple Factory）

**使用场景**：当需要根据不同条件创建不同类型的对象，且对象类型较少时使用。

```java
// 图形接口
public interface Shape {
    void draw();
}

// 圆形实现
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("绘制圆形");
    }
}

// 矩形实现
class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("绘制矩形");
    }
}

// 简单工厂类
class ShapeFactory {
    // 根据类型创建不同的图形对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        }
        return null;
    }
}

// 使用示例
class FactoryDemo {
    public static void main(String[] args) {
        // 通过工厂创建不同的图形
        Shape circle = ShapeFactory.getShape("CIRCLE");
        Shape rectangle = ShapeFactory.getShape("RECTANGLE");
        
        circle.draw();    // 输出"绘制圆形"
        rectangle.draw(); // 输出"绘制矩形"
    }
}
```

### 3. 工厂方法模式（Factory Method）

**使用场景**：当需要将对象创建延迟到子类，且产品类型较多或可能扩展时使用。

```java
// 文档接口
public interface Document {
    void open();
    void save();
}

// 文本文档
class TextDocument implements Document {
    @Override
    public void open() {
        System.out.println("打开文本文档");
    }
    
    @Override
    public void save() {
        System.out.println("保存文本文档");
    }
}

// 表格文档
class SpreadsheetDocument implements Document {
    @Override
    public void open() {
        System.out.println("打开表格文档");
    }
    
    @Override
    public void save() {
        System.out.println("保存表格文档");
    }
}

// 文档工厂接口（工厂方法）
interface DocumentFactory {
    Document createDocument();
}

// 文本文档工厂
class TextDocumentFactory implements DocumentFactory {
    @Override
    public Document createDocument() {
        return new TextDocument();
    }
}

// 表格文档工厂
class SpreadsheetDocumentFactory implements DocumentFactory {
    @Override
    public Document createDocument() {
        return new SpreadsheetDocument();
    }
}

// 文档编辑器
class DocumentEditor {
    private DocumentFactory factory;
    
    public DocumentEditor(DocumentFactory factory) {
        this.factory = factory;
    }
    
    public void newDocument() {
        Document doc = factory.createDocument();
        doc.open();
    }
}

// 使用示例
class FactoryMethodDemo {
    public static void main(String[] args) {
        // 创建文本编辑器
        DocumentEditor textEditor = new DocumentEditor(new TextDocumentFactory());
        textEditor.newDocument(); // 输出"打开文本文档"
        
        // 创建表格编辑器
        DocumentEditor spreadsheetEditor = new DocumentEditor(new SpreadsheetDocumentFactory());
        spreadsheetEditor.newDocument(); // 输出"打开表格文档"
    }
}
```

### 4. 抽象工厂模式（Abstract Factory）

**使用场景**：当需要创建一系列相关或相互依赖的对象时使用，例如不同主题的 UI 组件集。

```java
// 按钮接口
public interface Button {
    void paint();
}

// 文本框接口
public interface TextField {
    void paint();
}

// Windows按钮
class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println("绘制Windows风格按钮");
    }
}

// Windows文本框
class WindowsTextField implements TextField {
    @Override
    public void paint() {
        System.out.println("绘制Windows风格文本框");
    }
}

// Mac按钮
class MacButton implements Button {
    @Override
    public void paint() {
        System.out.println("绘制Mac风格按钮");
    }
}

// Mac文本框
class MacTextField implements TextField {
    @Override
    public void paint() {
        System.out.println("绘制Mac风格文本框");
    }
}

// 抽象工厂接口
interface GUIFactory {
    Button createButton();
    TextField createTextField();
}

// Windows工厂
class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }
    
    @Override
    public TextField createTextField() {
        return new WindowsTextField();
    }
}

// Mac工厂
class MacFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacButton();
    }
    
    @Override
    public TextField createTextField() {
        return new MacTextField();
    }
}

// 应用程序
class Application {
    private Button button;
    private TextField textField;
    
    public Application(GUIFactory factory) {
        button = factory.createButton();
        textField = factory.createTextField();
    }
    
    public void paint() {
        button.paint();
        textField.paint();
    }
}

// 使用示例
class AbstractFactoryDemo {
    public static void main(String[] args) {
        GUIFactory factory;
        
        // 根据系统类型选择不同的工厂
        String os = "Windows"; // 实际应用中可通过系统属性获取
        if (os.equals("Windows")) {
            factory = new WindowsFactory();
        } else {
            factory = new MacFactory();
        }
        
        Application app = new Application(factory);
        app.paint();
        // 在Windows系统下输出：
        // 绘制Windows风格按钮
        // 绘制Windows风格文本框
    }
}
```

### 5. 建造者模式（Builder）

**使用场景**：当需要创建复杂对象，且该对象有多个组成部分时使用，例如构建文档、汽车、复杂报表等。

```java
// 食物项
public interface Item {
    String name();
    float price();
    String packing();
}

// 汉堡
class Burger implements Item {
    private String name;
    private float price;
    
    public Burger(String name, float price) {
        this.name = name;
        this.price = price;
    }
    
    @Override
    public String name() {
        return name;
    }
    
    @Override
    public float price() {
        return price;
    }
    
    @Override
    public String packing() {
        return "纸盒";
    }
}

// 饮料
class Drink implements Item {
    private String name;
    private float price;
    
    public Drink(String name, float price) {
        this.name = name;
        this.price = price;
    }
    
    @Override
    public String name() {
        return name;
    }
    
    @Override
    public float price() {
        return price;
    }
    
    @Override
    public String packing() {
        return "纸杯";
    }
}

// 套餐
class Meal {
    private String name;
    private List<Item> items = new ArrayList<>();
    
    public void addItem(Item item) {
        items.add(item);
    }
    
    public float totalPrice() {
        return items.stream().mapToFloat(Item::price).sum();
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void showItems() {
        System.out.println("套餐: " + name);
        for (Item item : items) {
            System.out.println("名称: " + item.name() + 
                               ", 包装: " + item.packing() + 
                               ", 价格: " + item.price());
        }
        System.out.println("总价: " + totalPrice());
    }
}

// 建造者接口
interface MealBuilder {
    Meal build();
}

// 素食套餐建造者
class VegMealBuilder implements MealBuilder {
    @Override
    public Meal build() {
        Meal meal = new Meal();
        meal.setName("素食套餐");
        meal.addItem(new Burger("蔬菜汉堡", 25.0f));
        meal.addItem(new Drink("果汁", 10.0f));
        return meal;
    }
}

// 非素食套餐建造者
class NonVegMealBuilder implements MealBuilder {
    @Override
    public Meal build() {
        Meal meal = new Meal();
        meal.setName("非素食套餐");
        meal.addItem(new Burger("牛肉汉堡", 35.0f));
        meal.addItem(new Drink("可乐", 8.0f));
        return meal;
    }
}

// 指挥者（可选）
class MealDirector {
    private MealBuilder builder;
    
    public MealDirector(MealBuilder builder) {
        this.builder = builder;
    }
    
    public Meal construct() {
        return builder.build();
    }
}

// 使用示例
class BuilderDemo {
    public static void main(String[] args) {
        // 创建素食套餐
        MealBuilder vegBuilder = new VegMealBuilder();
        Meal vegMeal = vegBuilder.build();
        vegMeal.showItems();
        
        // 创建非素食套餐
        MealBuilder nonVegBuilder = new NonVegMealBuilder();
        Meal nonVegMeal = nonVegBuilder.build();
        nonVegMeal.showItems();
        
        // 也可以通过指挥者创建
        MealDirector director = new MealDirector(new VegMealBuilder());
        Meal meal = director.construct();
    }
}
```

### 6. 原型模式（Prototype）

**使用场景**：当创建对象的成本较高，或者需要动态生成多个相似对象时使用。

```java
// 原型接口
public interface Prototype extends Cloneable {
    Prototype clone();
    void draw();
}

// 圆形原型
class Circle implements Prototype {
    private int radius;
    private String color;
    
    public Circle(int radius, String color) {
        this.radius = radius;
        this.color = color;
        // 模拟复杂对象的创建成本
        try {
            Thread.sleep(1000); // 假设创建需要1秒时间
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    @Override
    public Prototype clone() {
        try {
            return (Circle) super.clone(); // 克隆比新建快很多
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }
    
    @Override
    public void draw() {
        System.out.println("绘制圆形 - 半径: " + radius + ", 颜色: " + color);
    }
    
    // 设置属性的方法
    public void setRadius(int radius) {
        this.radius = radius;
    }
    
    public void setColor(String color) {
        this.color = color;
    }
}

// 原型管理器
class PrototypeManager {
    private static Map<String, Prototype> prototypes = new HashMap<>();
    
    static {
        // 初始化原型
        prototypes.put("redCircle", new Circle(10, "红色"));
        prototypes.put("blueCircle", new Circle(15, "蓝色"));
    }
    
    public static Prototype getPrototype(String key) {
        // 克隆原型并返回
        return prototypes.get(key).clone();
    }
}

// 使用示例
class PrototypeDemo {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        
        // 第一次创建需要时间
        Circle original = new Circle(10, "红色");
        System.out.println("创建原始对象耗时: " + (System.currentTimeMillis() - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        // 通过克隆创建新对象
        Circle cloned1 = (Circle) original.clone();
        cloned1.setRadius(20);
        System.out.println("克隆对象耗时: " + (System.currentTimeMillis() - startTime) + "ms");
        
        // 通过原型管理器获取
        Circle cloned2 = (Circle) PrototypeManager.getPrototype("blueCircle");
        cloned2.setRadius(25);
        
        original.draw();  // 绘制圆形 - 半径: 10, 颜色: 红色
        cloned1.draw();   // 绘制圆形 - 半径: 20, 颜色: 红色
        cloned2.draw();   // 绘制圆形 - 半径: 25, 颜色: 蓝色
    }
}
```

## 二、结构型模式

结构型模式主要处理类和对象的组合，关注如何构建灵活且高效的系统结构。

### 1. 适配器模式（Adapter）

**使用场景**：当需要让两个不兼容的接口协同工作时，例如集成 legacy 系统或第三方库。

```java
// 目标接口：现代媒体播放器
public interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 适配者接口：旧的媒体播放器
interface AdvancedMediaPlayer {
    void playVlc(String fileName);
    void playMp4(String fileName);
}

// VLC播放器实现
class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("播放VLC文件: " + fileName);
    }
    
    @Override
    public void playMp4(String fileName) {
        // 不支持
    }
}

// MP4播放器实现
class Mp4Player implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        // 不支持
    }
    
    @Override
    public void playMp4(String fileName) {
        System.out.println("播放MP4文件: " + fileName);
    }
}

// 适配器类：连接新旧接口
class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedMusicPlayer;
    
    public MediaAdapter(String audioType) {
        if(audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer = new VlcPlayer();
        } else if(audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer = new Mp4Player();
        }
    }
    
    @Override
    public void play(String audioType, String fileName) {
        if(audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer.playVlc(fileName);
        } else if(audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}

// 具体媒体播放器
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;
    
    @Override
    public void play(String audioType, String fileName) {
        // 直接支持MP3
        if(audioType.equalsIgnoreCase("mp3")) {
            System.out.println("播放MP3文件: " + fileName);
        } 
        // 其他格式通过适配器支持
        else if(audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("不支持的格式: " + audioType);
        }
    }
}

// 使用示例
public class AdapterPatternDemo {
    public static void main(String[] args) {
        AudioPlayer audioPlayer = new AudioPlayer();
        
        audioPlayer.play("mp3", "song.mp3");
        audioPlayer.play("mp4", "movie.mp4");
        audioPlayer.play("vlc", "show.vlc");
        audioPlayer.play("avi", "video.avi");
    }
}
```

### 2. 装饰器模式（Decorator）

**使用场景**：需要动态地为对象添加功能，且这些功能可以灵活组合时使用，例如 Java IO 中的输入输出流。

```java
// 抽象组件：咖啡
public interface Coffee {
    String getDescription();
    double getCost();
}

// 具体组件：基础咖啡
class BasicCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "基础咖啡";
    }
    
    @Override
    public double getCost() {
        return 10.0;
    }
}

// 装饰器抽象类
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost();
    }
}

// 具体装饰器：牛奶
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", 加牛奶";
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 2.0;
    }
}

// 具体装饰器：糖
class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", 加糖";
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 1.0;
    }
}

// 具体装饰器：奶泡
class FoamDecorator extends CoffeeDecorator {
    public FoamDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", 加奶泡";
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 3.0;
    }
}

// 使用示例
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        // 基础咖啡
        Coffee coffee = new BasicCoffee();
        System.out.println(coffee.getDescription() + " 价格: " + coffee.getCost());
        
        // 加牛奶的咖啡
        Coffee milkCoffee = new MilkDecorator(new BasicCoffee());
        System.out.println(milkCoffee.getDescription() + " 价格: " + milkCoffee.getCost());
        
        // 加牛奶、糖和奶泡的咖啡
        Coffee specialCoffee = new FoamDecorator(
            new SugarDecorator(
                new MilkDecorator(new BasicCoffee())
            )
        );
        System.out.println(specialCoffee.getDescription() + " 价格: " + specialCoffee.getCost());
    }
}
```

### 3. 代理模式（Proxy）

**使用场景**：需要控制对对象的访问，例如延迟加载、权限控制、日志记录等。

```java
// 抽象主题：图像
public interface Image {
    void display();
}

// 真实主题：高清图像
class HighResolutionImage implements Image {
    private String imageFilePath;
    
    public HighResolutionImage(String imageFilePath) {
        this.imageFilePath = imageFilePath;
        loadImageFromDisk(); // 加载图像（耗时操作）
    }
    
    // 模拟从磁盘加载高清图像（耗时操作）
    private void loadImageFromDisk() {
        System.out.println("从磁盘加载高清图像: " + imageFilePath);
        try {
            Thread.sleep(2000); // 模拟加载耗时
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    @Override
    public void display() {
        System.out.println("显示高清图像: " + imageFilePath);
    }
}

// 代理类：图像代理（虚拟代理）
class ImageProxy implements Image {
    private HighResolutionImage highResImage;
    private String imageFilePath;
    private boolean isLoaded = false;
    
    public ImageProxy(String imageFilePath) {
        this.imageFilePath = imageFilePath;
    }
    
    @Override
    public void display() {
        // 延迟加载：只在需要显示时才真正加载
        if (!isLoaded) {
            highResImage = new HighResolutionImage(imageFilePath);
            isLoaded = true;
        }
        highResImage.display();
    }
}

// 使用示例
public class ProxyPatternDemo {
    public static void main(String[] args) {
        // 创建代理，此时不会加载图像
        Image image1 = new ImageProxy("photo1.jpg");
        Image image2 = new ImageProxy("photo2.jpg");
        
        System.out.println("准备显示第一张图片...");
        // 第一次显示时才加载
        image1.display();
        
        System.out.println("\n准备再次显示第一张图片...");
        // 已经加载过，直接显示
        image1.display();
        
        System.out.println("\n准备显示第二张图片...");
        image2.display();
    }
}
```

### 4. 组合模式（Composite）

**使用场景**：当需要处理树形结构，且希望统一对待单个对象和对象组合时使用，例如文件系统、UI 组件树。

```java
// 抽象组件：文件系统节点
public abstract class FileSystemNode {
    protected String name;
    
    public FileSystemNode(String name) {
        this.name = name;
    }
    
    public abstract void print(String prefix);
    public abstract long getSize();
}

// 叶子节点：文件
class File extends FileSystemNode {
    private long size;
    
    public File(String name, long size) {
        super(name);
        this.size = size;
    }
    
    @Override
    public void print(String prefix) {
        System.out.println(prefix + "/ " + name + " (" + size + "KB)");
    }
    
    @Override
    public long getSize() {
        return size;
    }
}

// 组合节点：目录
class Directory extends FileSystemNode {
    private List<FileSystemNode> children = new ArrayList<>();
    
    public Directory(String name) {
        super(name);
    }
    
    public void addNode(FileSystemNode node) {
        children.add(node);
    }
    
    public void removeNode(FileSystemNode node) {
        children.remove(node);
    }
    
    @Override
    public void print(String prefix) {
        System.out.println(prefix + "/ " + name);
        String newPrefix = prefix + "  ";
        for (FileSystemNode node : children) {
            node.print(newPrefix);
        }
    }
    
    @Override
    public long getSize() {
        // 目录大小是所有子节点大小之和
        return children.stream().mapToLong(FileSystemNode::getSize).sum();
    }
}

// 使用示例
public class CompositePatternDemo {
    public static void main(String[] args) {
        // 创建文件系统结构
        Directory root = new Directory("root");
        
        Directory etc = new Directory("etc");
        etc.addNode(new File("hosts", 1));
        etc.addNode(new File("config", 2));
        
        Directory home = new Directory("home");
        Directory user = new Directory("user");
        user.addNode(new File("document.txt", 10));
        user.addNode(new File("image.jpg", 100));
        home.addNode(user);
        
        root.addNode(etc);
        root.addNode(home);
        root.addNode(new File("readme.txt", 5));
        
        // 打印文件系统结构
        System.out.println("文件系统结构:");
        root.print("");
        
        // 计算总大小
        System.out.println("\nroot目录总大小: " + root.getSize() + "KB");
        System.out.println("home目录总大小: " + home.getSize() + "KB");
    }
}
```

### 5. 外观模式（Facade）

**使用场景**：当需要为复杂系统提供一个简单接口时使用，例如框架的 API 封装、第三方库的简化调用。

```java
// 子系统1：CPU
class CPU {
    public void powerOn() {
        System.out.println("CPU 启动");
    }
    
    public void powerOff() {
        System.out.println("CPU 关闭");
    }
    
    public void execute() {
        System.out.println("CPU 执行指令");
    }
}

// 子系统2：内存
class Memory {
    public void load() {
        System.out.println("内存加载数据");
    }
    
    public void clear() {
        System.out.println("内存清空");
    }
}

// 子系统3：硬盘
class HardDrive {
    public void read() {
        System.out.println("硬盘读取数据");
    }
    
    public void write() {
        System.out.println("硬盘写入数据");
    }
}

// 子系统4：显示器
class Display {
    public void turnOn() {
        System.out.println("显示器打开");
    }
    
    public void turnOff() {
        System.out.println("显示器关闭");
    }
    
    public void displayData() {
        System.out.println("显示器显示内容");
    }
}

// 外观类：计算机
class ComputerFacade {
    private CPU cpu;
    private Memory memory;
    private HardDrive hardDrive;
    private Display display;
    
    public ComputerFacade() {
        this.cpu = new CPU();
        this.memory = new Memory();
        this.hardDrive = new HardDrive();
        this.display = new Display();
    }
    
    // 简化的启动接口
    public void start() {
        System.out.println("===== 启动计算机 =====");
        cpu.powerOn();
        memory.load();
        hardDrive.read();
        display.turnOn();
        cpu.execute();
        display.displayData();
        System.out.println("===== 计算机启动完成 =====");
    }
    
    // 简化的关闭接口
    public void shutdown() {
        System.out.println("\n===== 关闭计算机 =====");
        display.turnOff();
        memory.clear();
        cpu.powerOff();
        System.out.println("===== 计算机已关闭 =====");
    }
}

// 使用示例
public class FacadePatternDemo {
    public static void main(String[] args) {
        // 客户端只需与外观交互，无需了解子系统细节
        ComputerFacade computer = new ComputerFacade();
        computer.start();
        computer.shutdown();
    }
}
```

### 6. 桥接模式（Bridge）

**使用场景**：当需要分离抽象与实现，且两者都可能独立变化时使用，例如跨平台组件、设备与驱动程序。

```java
// 实现部分接口：颜色
public interface Color {
    String getColor();
}

// 具体实现：红色
class Red implements Color {
    @Override
    public String getColor() {
        return "红色";
    }
}

// 具体实现：蓝色
class Blue implements Color {
    @Override
    public String getColor() {
        return "蓝色";
    }
}

// 抽象部分：形状
abstract class Shape {
    // 桥接：引用实现部分
    protected Color color;
    
    public Shape(Color color) {
        this.color = color;
    }
    
    public abstract void draw();
}

// 扩展抽象：圆形
class Circle extends Shape {
    private int radius;
    
    public Circle(Color color, int radius) {
        super(color);
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制一个" + color.getColor() + "的圆形，半径：" + radius);
    }
}

// 扩展抽象：矩形
class Rectangle extends Shape {
    private int width;
    private int height;
    
    public Rectangle(Color color, int width, int height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        System.out.println("绘制一个" + color.getColor() + "的矩形，宽：" + width + "，高：" + height);
    }
}

// 使用示例
public class BridgePatternDemo {
    public static void main(String[] args) {
        // 红色圆形
        Shape redCircle = new Circle(new Red(), 10);
        redCircle.draw();
        
        // 蓝色矩形
        Shape blueRectangle = new Rectangle(new Blue(), 20, 30);
        blueRectangle.draw();
        
        // 红色矩形（抽象和实现可以独立变化组合）
        Shape redRectangle = new Rectangle(new Red(), 15, 25);
        redRectangle.draw();
    }
}
```

### 7. 享元模式（Flyweight）

**使用场景**：当需要创建大量相似对象，且希望节省内存时使用，例如文本编辑器中的字符、游戏中的粒子系统。

```java
// 享元接口：字符
public interface Character {
    void display(int positionX, int positionY); // 外部状态：位置
}

// 具体享元：具体字符
class ConcreteCharacter implements Character {
    // 内部状态：字符值和样式（共享）
    private char character;
    private String font;
    private int size;
    
    public ConcreteCharacter(char character, String font, int size) {
        this.character = character;
        this.font = font;
        this.size = size;
    }
    
    @Override
    public void display(int positionX, int positionY) {
        System.out.println("显示字符 '" + character + "'，字体：" + font + 
                          "，大小：" + size + "，位置：(" + positionX + "," + positionY + ")");
    }
}

// 享元工厂：字符工厂
class CharacterFactory {
    // 缓存已创建的享元对象
    private Map<String, Character> characters = new HashMap<>();
    
    public Character getCharacter(char c, String font, int size) {
        // 创建唯一键标识享元
        String key = c + "-" + font + "-" + size;
        
        // 如果不存在则创建并缓存
        if (!characters.containsKey(key)) {
            characters.put(key, new ConcreteCharacter(c, font, size));
            System.out.println("创建新字符: " + key);
        }
        
        return characters.get(key);
    }
    
    public int getCharacterCount() {
        return characters.size();
    }
}

// 使用示例
public class FlyweightPatternDemo {
    public static void main(String[] args) {
        CharacterFactory factory = new CharacterFactory();
        
        // 编辑文本 "ABAC"，其中A出现两次
        Character a1 = factory.getCharacter('A', "Arial", 12);
        a1.display(10, 20);
        
        Character b = factory.getCharacter('B', "Arial", 12);
        b.display(20, 20);
        
        Character a2 = factory.getCharacter('A', "Arial", 12);
        a2.display(30, 20);
        
        Character c = factory.getCharacter('C', "Arial", 12);
        c.display(40, 20);
        
        // 显示缓存的字符数量（应该是3个：A、B、C）
        System.out.println("\n缓存的字符总数: " + factory.getCharacterCount());
        
        // 验证a1和a2是否是同一个对象
        System.out.println("a1和a2是否为同一对象: " + (a1 == a2));
    }
}
```

## 三、行为型模式

行为型模式主要关注对象之间的通信和职责分配，解决对象行为的协作问题。

### 1. 观察者模式（Observer）

**使用场景**：当一个对象的状态变化需要通知多个其他对象时使用，例如事件监听、消息订阅系统。

```java
// 主题接口（被观察者）
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// 观察者接口
public interface Observer {
    void update(String news);
}

// 具体主题：新闻发布者
class NewsPublisher implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String latestNews;
    
    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }
    
    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    
    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(latestNews);
        }
    }
    
    // 发布新闻
    public void publishNews(String news) {
        this.latestNews = news;
        System.out.println("\n发布新闻: " + news);
        notifyObservers(); // 通知所有观察者
    }
}

// 具体观察者：邮件订阅者
class EmailSubscriber implements Observer {
    private String email;
    
    public EmailSubscriber(String email) {
        this.email = email;
    }
    
    @Override
    public void update(String news) {
        System.out.println("发送邮件给 " + email + ": " + news);
    }
}

// 具体观察者：APP订阅者
class AppSubscriber implements Observer {
    private String username;
    
    public AppSubscriber(String username) {
        this.username = username;
    }
    
    @Override
    public void update(String news) {
        System.out.println("APP推送通知给 " + username + ": " + news);
    }
}

// 使用示例
public class ObserverPatternDemo {
    public static void main(String[] args) {
        // 创建新闻发布者
        NewsPublisher publisher = new NewsPublisher();
        
        // 创建订阅者
        Observer subscriber1 = new EmailSubscriber("user1@example.com");
        Observer subscriber2 = new AppSubscriber("mobile_user");
        Observer subscriber3 = new EmailSubscriber("user2@example.com");
        
        // 注册订阅者
        publisher.registerObserver(subscriber1);
        publisher.registerObserver(subscriber2);
        publisher.registerObserver(subscriber3);
        
        // 发布第一条新闻
        publisher.publishNews("设计模式学习指南发布");
        
        // 移除一个订阅者
        publisher.removeObserver(subscriber3);
        
        // 发布第二条新闻
        publisher.publishNews("Java编程技巧更新");
    }
}
```

### 2. 策略模式（Strategy）

**使用场景**：当需要在运行时选择不同算法或行为时使用，例如支付方式选择、排序算法切换。

```java
// 策略接口：支付方式
public interface PaymentStrategy {
    void pay(double amount);
}

// 具体策略：信用卡支付
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    private String name;
    private String cvv;
    
    public CreditCardPayment(String cardNumber, String name, String cvv) {
        this.cardNumber = cardNumber;
        this.name = name;
        this.cvv = cvv;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println(amount + " 元通过信用卡支付: " + 
                          cardNumber.substring(cardNumber.length() - 4));
    }
}

// 具体策略：支付宝支付
class AlipayPayment implements PaymentStrategy {
    private String account;
    
    public AlipayPayment(String account) {
        this.account = account;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println(amount + " 元通过支付宝支付: " + account);
    }
}

// 具体策略：微信支付
class WechatPayment implements PaymentStrategy {
    private String wechatId;
    
    public WechatPayment(String wechatId) {
        this.wechatId = wechatId;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println(amount + " 元通过微信支付: " + wechatId);
    }
}

// 上下文：购物车
class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    
    // 设置支付策略
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }
    
    // 结算
    public void checkout(double amount) {
        if (paymentStrategy == null) {
            throw new IllegalStateException("请选择支付方式");
        }
        paymentStrategy.pay(amount);
    }
}

// 使用示例
public class StrategyPatternDemo {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        
        // 选择信用卡支付
        cart.setPaymentStrategy(new CreditCardPayment("4111-1111-1111-1234", "张三", "123"));
        cart.checkout(299.99);
        
        // 切换到支付宝支付
        cart.setPaymentStrategy(new AlipayPayment("zhangsan@alipay.com"));
        cart.checkout(159.50);
        
        // 切换到微信支付
        cart.setPaymentStrategy(new WechatPayment("wxid_123456"));
        cart.checkout(89.90);
    }
}
```

### 3. 模板方法模式（Template Method）

**使用场景**：当需要定义算法骨架，而将某些步骤延迟到子类实现时使用，例如框架中的生命周期方法。

```java
// 抽象类：饮料制作模板
public abstract class BeverageMaker {
    // 模板方法：定义算法骨架，声明为final防止子类修改
    public final void makeBeverage() {
        boilWater();         // 步骤1：煮水
        brew();              // 步骤2：冲泡（子类实现）
        pourInCup();         // 步骤3：倒入杯中
        if (customerWantsCondiments()) { // 钩子方法：判断是否加调料
            addCondiments(); // 步骤4：加调料（子类实现）
        }
        System.out.println("饮料制作完成！");
    }
    
    // 抽象方法：冲泡（子类实现）
    protected abstract void brew();
    
    // 抽象方法：加调料（子类实现）
    protected abstract void addCondiments();
    
    // 具体方法：煮水（共用实现）
    private void boilWater() {
        System.out.println("煮水");
    }
    
    // 具体方法：倒入杯中（共用实现）
    private void pourInCup() {
        System.out.println("倒入杯中");
    }
    
    // 钩子方法：默认加调料
    protected boolean customerWantsCondiments() {
        return true;
    }
}

// 具体子类：咖啡
class Coffee extends BeverageMaker {
    @Override
    protected void brew() {
        System.out.println("冲泡咖啡");
    }
    
    @Override
    protected void addCondiments() {
        System.out.println("加糖和牛奶");
    }
    
    // 重写钩子方法：询问是否加调料
    @Override
    protected boolean customerWantsCondiments() {
        // 实际应用中可以在这里实现用户交互
        return true; // 假设用户想要加调料
    }
}

// 具体子类：茶
class Tea extends BeverageMaker {
    @Override
    protected void brew() {
        System.out.println("浸泡茶叶");
    }
    
    @Override
    protected void addCondiments() {
        System.out.println("加柠檬");
    }
    
    // 重写钩子方法：不加调料
    @Override
    protected boolean customerWantsCondiments() {
        return false; // 茶不加调料
    }
}

// 使用示例
public class TemplateMethodDemo {
    public static void main(String[] args) {
        System.out.println("制作咖啡：");
        BeverageMaker coffee = new Coffee();
        coffee.makeBeverage();
        
        System.out.println("\n制作茶：");
        BeverageMaker tea = new Tea();
        tea.makeBeverage();
    }
}
```

### 4. 命令模式（Command）

**使用场景**：当需要将请求封装为对象，支持请求排队、撤销操作时使用，例如 GUI 按钮命令、事务操作。

```java
// 命令接口
public interface Command {
    void execute();
    void undo();
}

// 接收者：电灯
class Light {
    private String location;
    
    public Light(String location) {
        this.location = location;
    }
    
    public void on() {
        System.out.println(location + " 电灯打开");
    }
    
    public void off() {
        System.out.println(location + " 电灯关闭");
    }
}

// 接收者：音响
class Stereo {
    public void on() {
        System.out.println("音响打开");
    }
    
    public void off() {
        System.out.println("音响关闭");
    }
    
    public void setVolume(int volume) {
        System.out.println("音响音量设置为 " + volume);
    }
}

// 具体命令：开灯
class LightOnCommand implements Command {
    private Light light;
    
    public LightOnCommand(Light light) {
        this.light = light;
    }
    
    @Override
    public void execute() {
        light.on();
    }
    
    @Override
    public void undo() {
        light.off();
    }
}

// 具体命令：关灯
class LightOffCommand implements Command {
    private Light light;
    
    public LightOffCommand(Light light) {
        this.light = light;
    }
    
    @Override
    public void execute() {
        light.off();
    }
    
    @Override
    public void undo() {
        light.on();
    }
}

// 具体命令：打开音响并设置音量
class StereoOnWithVolumeCommand implements Command {
    private Stereo stereo;
    private int previousVolume;
    
    public StereoOnWithVolumeCommand(Stereo stereo) {
        this.stereo = stereo;
    }
    
    @Override
    public void execute() {
        stereo.on();
        previousVolume = 10; // 假设之前音量是10
        stereo.setVolume(15);
    }
    
    @Override
    public void undo() {
        stereo.setVolume(previousVolume);
        stereo.off();
    }
}

// 调用者：遥控器
class RemoteControl {
    private Command[] onCommands;
    private Command[] offCommands;
    private Command undoCommand;
    
    public RemoteControl() {
        onCommands = new Command[2];
        offCommands = new Command[2];
        
        // 空命令，避免空指针
        Command noCommand = new NoCommand();
        for (int i = 0; i < 2; i++) {
            onCommands[i] = noCommand;
            offCommands[i] = noCommand;
        }
        undoCommand = noCommand;
    }
    
    public void setCommand(int slot, Command onCommand, Command offCommand) {
        onCommands[slot] = onCommand;
        offCommands[slot] = offCommand;
    }
    
    public void pressOnButton(int slot) {
        onCommands[slot].execute();
        undoCommand = onCommands[slot];
    }
    
    public void pressOffButton(int slot) {
        offCommands[slot].execute();
        undoCommand = offCommands[slot];
    }
    
    public void pressUndoButton() {
        undoCommand.undo();
    }
}

// 空命令（默认命令）
class NoCommand implements Command {
    @Override
    public void execute() {}
    
    @Override
    public void undo() {}
}

// 使用示例
public class CommandPatternDemo {
    public static void main(String[] args) {
        // 创建遥控器
        RemoteControl remote = new RemoteControl();
        
        // 创建接收者
        Light livingRoomLight = new Light("客厅");
        Stereo stereo = new Stereo();
        
        // 创建命令
        Command livingRoomLightOn = new LightOnCommand(livingRoomLight);
        Command livingRoomLightOff = new LightOffCommand(livingRoomLight);
        Command stereoOn = new StereoOnWithVolumeCommand(stereo);
        
        // 设置命令到遥控器
        remote.setCommand(0, livingRoomLightOn, livingRoomLightOff);
        remote.setCommand(1, stereoOn, new LightOffCommand(null)); // 简化示例
        
        // 测试遥控器
        System.out.println("按下客厅灯开按钮");
        remote.pressOnButton(0);
        
        System.out.println("按下撤销按钮");
        remote.pressUndoButton();
        
        System.out.println("\n按下音响开按钮");
        remote.pressOnButton(1);
        
        System.out.println("按下撤销按钮");
        remote.pressUndoButton();
    }
}
```

### 5. 状态模式（State）

**使用场景**：当对象的行为依赖于其状态，且状态可能在运行时改变时使用，例如订单状态流转、电梯状态控制。

```java
// 状态接口
public interface OrderState {
    void payOrder(Order order);
    void shipOrder(Order order);
    void deliverOrder(Order order);
    void cancelOrder(Order order);
    String getStatus();
}

// 具体状态：新建订单
class NewOrderState implements OrderState {
    @Override
    public void payOrder(Order order) {
        System.out.println("订单支付成功");
        order.setState(new PaidOrderState());
    }
    
    @Override
    public void shipOrder(Order order) {
        System.out.println("无法发货 - 订单尚未支付");
    }
    
    @Override
    public void deliverOrder(Order order) {
        System.out.println("无法送达 - 订单尚未支付");
    }
    
    @Override
    public void cancelOrder(Order order) {
        System.out.println("订单已取消");
        order.setState(new CancelledOrderState());
    }
    
    @Override
    public String getStatus() {
        return "新建";
    }
}

// 具体状态：已支付订单
class PaidOrderState implements OrderState {
    @Override
    public void payOrder(Order order) {
        System.out.println("订单已支付，无需重复支付");
    }
    
    @Override
    public void shipOrder(Order order) {
        System.out.println("订单已发货");
        order.setState(new ShippedOrderState());
    }
    
    @Override
    public void deliverOrder(Order order) {
        System.out.println("无法送达 - 订单尚未发货");
    }
    
    @Override
    public void cancelOrder(Order order) {
        System.out.println("订单已取消，将安排退款");
        order.setState(new CancelledOrderState());
    }
    
    @Override
    public String getStatus() {
        return "已支付";
    }
}

// 具体状态：已发货订单
class ShippedOrderState implements OrderState {
    @Override
    public void payOrder(Order order) {
        System.out.println("订单已支付，无需重复支付");
    }
    
    @Override
    public void shipOrder(Order order) {
        System.out.println("订单已发货，无需重复发货");
    }
    
    @Override
    public void deliverOrder(Order order) {
        System.out.println("订单已送达");
        order.setState(new DeliveredOrderState());
    }
    
    @Override
    public void cancelOrder(Order order) {
        System.out.println("订单已发货，无法取消");
    }
    
    @Override
    public String getStatus() {
        return "已发货";
    }
}

// 具体状态：已送达订单
class DeliveredOrderState implements OrderState {
    @Override
    public void payOrder(Order order) {
        System.out.println("订单已完成，无需支付");
    }
    
    @Override
    public void shipOrder(Order order) {
        System.out.println("订单已完成，无需发货");
    }
    
    @Override
    public void deliverOrder(Order order) {
        System.out.println("订单已送达，无需重复操作");
    }
    
    @Override
    public void cancelOrder(Order order) {
        System.out.println("订单已完成，无法取消");
    }
    
    @Override
    public String getStatus() {
        return "已送达";
    }
}

// 具体状态：已取消订单
class CancelledOrderState implements OrderState {
    @Override
    public void payOrder(Order order) {
        System.out.println("订单已取消，无法支付");
    }
    
    @Override
    public void shipOrder(Order order) {
        System.out.println("订单已取消，无法发货");
    }
    
    @Override
    public void deliverOrder(Order order) {
        System.out.println("订单已取消，无法送达");
    }
    
    @Override
    public void cancelOrder(Order order) {
        System.out.println("订单已取消，无需重复操作");
    }
    
    @Override
    public String getStatus() {
        return "已取消";
    }
}

// 环境类：订单
class Order {
    private OrderState state;
    private String orderId;
    
    public Order(String orderId) {
        this.orderId = orderId;
        this.state = new NewOrderState(); // 初始状态为新建
    }
    
    public void setState(OrderState state) {
        this.state = state;
    }
    
    public void pay() {
        state.payOrder(this);
    }
    
    public void ship() {
        state.shipOrder(this);
    }
    
    public void deliver() {
        state.deliverOrder(this);
    }
    
    public void cancel() {
        state.cancelOrder(this);
    }
    
    public void showStatus() {
        System.out.println("订单 " + orderId + " 当前状态: " + state.getStatus());
    }
}

// 使用示例
public class StatePatternDemo {
    public static void main(String[] args) {
        Order order = new Order("ORD-12345");
        order.showStatus();
        
        order.pay();
        order.showStatus();
        
        order.ship();
        order.showStatus();
        
        order.deliver();
        order.showStatus();
        
        // 尝试取消已完成的订单
        order.cancel();
        
        // 创建另一个订单并取消
        Order order2 = new Order("ORD-67890");
        order2.cancel();
        order2.showStatus();
    }
}
```

### 6. 迭代器模式（Iterator）

**使用场景**：当需要遍历聚合对象而不暴露其内部结构时使用，例如集合框架中的迭代器。

```java
// 迭代器接口
public interface Iterator {
    boolean hasNext();
    Object next();
}

// 聚合接口
public interface Menu {
    Iterator createIterator();
}

// 菜单项
class MenuItem {
    private String name;
    private String description;
    private boolean vegetarian;
    private double price;
    
    public MenuItem(String name, String description, boolean vegetarian, double price) {
        this.name = name;
        this.description = description;
        this.vegetarian = vegetarian;
        this.price = price;
    }
    
    // getter方法
    public String getName() { return name; }
    public String getDescription() { return description; }
    public boolean isVegetarian() { return vegetarian; }
    public double getPrice() { return price; }
}

// 早餐菜单（使用数组存储）
class BreakfastMenu implements Menu {
    private static final int MAX_ITEMS = 6;
    private int numberOfItems = 0;
    private MenuItem[] menuItems;
    
    public BreakfastMenu() {
        menuItems = new MenuItem[MAX_ITEMS];
        
        // 添加菜单项
        addItem("早餐三明治", "面包、鸡蛋和培根", false, 3.99);
        addItem("水果沙拉", "混合水果配酸奶", true, 2.99);
        addItem("咖啡", "黑咖啡", true, 1.99);
    }
    
    public void addItem(String name, String description, boolean vegetarian, double price) {
        if (numberOfItems >= MAX_ITEMS) {
            System.err.println("菜单已满，无法添加");
        } else {
            menuItems[numberOfItems] = new MenuItem(name, description, vegetarian, price);
            numberOfItems++;
        }
    }
    
    @Override
    public Iterator createIterator() {
        return new BreakfastMenuIterator(menuItems);
    }
}

// 早餐菜单迭代器
class BreakfastMenuIterator implements Iterator {
    private MenuItem[] items;
    private int position = 0;
    
    public BreakfastMenuIterator(MenuItem[] items) {
        this.items = items;
    }
    
    @Override
    public boolean hasNext() {
        return position < items.length && items[position] != null;
    }
    
    @Override
    public Object next() {
        MenuItem menuItem = items[position];
        position++;
        return menuItem;
    }
}

// 晚餐菜单（使用ArrayList存储）
class DinnerMenu implements Menu {
    private List<MenuItem> menuItems;
    
    public DinnerMenu() {
        menuItems = new ArrayList<>();
        
        // 添加菜单项
        addItem("牛排", "西冷牛排配薯条", false, 15.99);
        addItem("蔬菜意面", "意大利面配时蔬", true, 10.99);
        addItem("三文鱼", "烤三文鱼配蔬菜", false, 18.99);
        addItem("冰淇淋", "香草冰淇淋", true, 5.99);
    }
    
    public void addItem(String name, String description, boolean vegetarian, double price) {
        menuItems.add(new MenuItem(name, description, vegetarian, price));
    }
    
    @Override
    public Iterator createIterator() {
        return new DinnerMenuIterator(menuItems);
    }
}

// 晚餐菜单迭代器
class DinnerMenuIterator implements Iterator {
    private List<MenuItem> items;
    private int position = 0;
    
    public DinnerMenuIterator(List<MenuItem> items) {
        this.items = items;
    }
    
    @Override
    public boolean hasNext() {
        return position < items.size();
    }
    
    @Override
    public Object next() {
        MenuItem menuItem = items.get(position);
        position++;
        return menuItem;
    }
}

// 服务员（使用迭代器遍历菜单）
class Waitress {
    private Menu breakfastMenu;
    private Menu dinnerMenu;
    
    public Waitress(Menu breakfastMenu, Menu dinnerMenu) {
        this.breakfastMenu = breakfastMenu;
        this.dinnerMenu = dinnerMenu;
    }
    
    public void printMenu() {
        Iterator breakfastIterator = breakfastMenu.createIterator();
        Iterator dinnerIterator = dinnerMenu.createIterator();
        
        System.out.println("===== 早餐菜单 =====");
        printMenu(breakfastIterator);
        
        System.out.println("\n===== 晚餐菜单 =====");
        printMenu(dinnerIterator);
    }
    
    public void printVegetarianMenu() {
        System.out.println("\n===== 素食菜单 =====");
        printVegetarianMenu(breakfastMenu.createIterator());
        printVegetarianMenu(dinnerMenu.createIterator());
    }
    
    private void printMenu(Iterator iterator) {
        while (iterator.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator.next();
            System.out.println(menuItem.getName() + " - " + 
                              menuItem.getDescription() + " - " + 
                              menuItem.getPrice() + "元");
        }
    }
    
    private void printVegetarianMenu(Iterator iterator) {
        while (iterator.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator.next();
            if (menuItem.isVegetarian()) {
                System.out.println(menuItem.getName() + " - " + 
                                  menuItem.getDescription() + " - " + 
                                  menuItem.getPrice() + "元");
            }
        }
    }
}

// 使用示例
public class IteratorPatternDemo {
    public static void main(String[] args) {
        Menu breakfastMenu = new BreakfastMenu();
        Menu dinnerMenu = new DinnerMenu();
        
        Waitress waitress = new Waitress(breakfastMenu, dinnerMenu);
        waitress.printMenu();
        waitress.printVegetarianMenu();
    }
}
```

### 7. 中介者模式（Mediator）

**使用场景**：当多个对象之间存在复杂交互，希望减少它们之间的直接依赖时使用，例如聊天室、GUI 组件交互。

```java
// 中介者接口
public interface ChatMediator {
    void sendMessage(String message, User user);
    void addUser(User user);
}

// 抽象同事类：用户
public abstract class User {
    protected ChatMediator mediator;
    protected String name;
    
    public User(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }
    
    public abstract void send(String message);
    public abstract void receive(String message);
}

// 具体中介者：聊天室
class ChatRoom implements ChatMediator {
    private List<User> users;
    
    public ChatRoom() {
        this.users = new ArrayList<>();
    }
    
    @Override
    public void addUser(User user) {
        users.add(user);
    }
    
    @Override
    public void sendMessage(String message, User sender) {
        // 向所有用户发送消息，除了发送者
        for (User user : users) {
            if (user != sender) {
                user.receive(message);
            }
        }
    }
}

// 具体同事类：普通用户
class ChatUser extends User {
    public ChatUser(ChatMediator mediator, String name) {
        super(mediator, name);
    }
    
    @Override
    public void send(String message) {
        System.out.println(name + " 发送消息: " + message);
        mediator.sendMessage(message, this);
    }
    
    @Override
    public void receive(String message) {
        System.out.println(name + " 收到消息: " + message);
    }
}

// 使用示例
public class MediatorPatternDemo {
    public static void main(String[] args) {
        ChatMediator chatRoom = new ChatRoom();
        
        User user1 = new ChatUser(chatRoom, "张三");
        User user2 = new ChatUser(chatRoom, "李四");
        User user3 = new ChatUser(chatRoom, "王五");
        
        chatRoom.addUser(user1);
        chatRoom.addUser(user2);
        chatRoom.addUser(user3);
        
        user1.send("大家好！");
        System.out.println();
        user2.send("你们好，我是李四");
        System.out.println();
        user3.send("很高兴认识大家");
    }
}
```

## 总结

设计模式是软件开发中经过验证的最佳实践，合理使用可以显著提高代码质量：



- **创建型模式**：关注对象创建机制，包括单例、工厂系列、建造者和原型模式
- **结构型模式**：处理类和对象的组合，包括适配器、装饰器、代理、组合等模式
- **行为型模式**：关注对象间通信和职责分配，包括观察者、策略、命令等模式



选择设计模式应基于实际问题场景，而非为了使用模式而使用。熟练掌握设计模式可以帮助开发者编写更优雅、更易维护的代码，尤其是在大型项目中能显著提升团队协作效率。