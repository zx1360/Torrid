模式名(gallery)
为确保数据一致性和原子性, 建议合理使用事务来确保.

建表:
-- 文件信息表media_assets
-- 文件信息表media_assets
CREATE TABLE
IF
	NOT EXISTS media_assets (
		ID UUID PRIMARY KEY,
		created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,-- 入库时间
		updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,-- 修改时间
		captured_at TIMESTAMPTZ NOT NULL,-- 优先级: EXIF > 修改时间 > 创建时间
		file_path TEXT NOT NULL,-- 存储中的相对路径
		thumb_path TEXT,-- 生成的缩略图/封面图相对路径
		preview_path TEXT,-- 生成的预览图相对路径
		hash BYTEA NOT NULL UNIQUE,-- SHA-256 用于去重
		size_bytes BIGINT NOT NULL DEFAULT 0,
		mime_type TEXT,
		is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
		sync_count INTEGER NOT NULL DEFAULT 0,-- 表示该媒体文件记录从移动端被同步到服务端的次数
		group_id UUID DEFAULT NULL,-- 指向“主文件”的 ID。如果不为空，代表该文件被捆绑.
		message TEXT default null,
		CONSTRAINT fk_group_id FOREIGN KEY ( group_id ) REFERENCES media_assets ( ID ) ON DELETE 
	SET NULL 
	);
-- 为media_assets添加索引
CREATE INDEX
IF
	NOT EXISTS idx_media_assets_sync_captured ON media_assets ( is_deleted, sync_count, captured_at );
CREATE INDEX
IF
	NOT EXISTS idx_media_assets_updated_at ON media_assets ( updated_at );-- 更新日期排序.
CREATE INDEX
IF
	NOT EXISTS idx_media_assets_group_id ON media_assets ( group_id );--主文件查询
CREATE INDEX
IF
	NOT EXISTS idx_media_assets_mime_type ON media_assets ( mime_type );--按文件类型排序

-- 标签表tags, 树状结构
CREATE TABLE
IF
	NOT EXISTS tags (
		ID UUID PRIMARY KEY,
		created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
		updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
		NAME TEXT NOT NULL,
		parent_id UUID,-- 记录其父标签, 根节点为 Null.
		full_path TEXT,-- 冗余字段用于快速搜索, (例如 "Family/2023/Xmas"). 级联更新.
		CONSTRAINT fk_parent_id FOREIGN KEY ( parent_id ) REFERENCES tags ( ID ) ON DELETE CASCADE,
		CONSTRAINT uk_tag_name_parent UNIQUE ( NAME, parent_id ) 
	);
-- 为tags添加索引
CREATE INDEX
IF
	NOT EXISTS idx_tags_parent_id ON tags ( parent_id );-- 按父标签查询子标签
CREATE INDEX
IF
	NOT EXISTS idx_tags_full_path ON tags ( full_path );-- 按完整路径快速搜索

-- 文件标签关联表media_tag_links
CREATE TABLE
IF
	NOT EXISTS media_tag_links (
		media_id UUID,
		tag_id UUID,
		PRIMARY KEY ( tag_id, media_id ),
		CONSTRAINT fk_media_id FOREIGN KEY ( media_id ) REFERENCES media_assets ( ID ) ON DELETE CASCADE,
		CONSTRAINT fk_tag_id FOREIGN KEY ( tag_id ) REFERENCES tags ( ID ) ON DELETE CASCADE 
	);
-- 为media_tag_links添加索引
CREATE INDEX
IF
	NOT EXISTS idx_media_tag_links_media_id ON media_tag_links ( media_id );-- 按媒体ID查询关联媒体



触发器_更新时间:
-- 创建通用的updated_at自动更新触发器函数
CREATE 
	OR REPLACE FUNCTION update_updated_at_column ( ) RETURNS TRIGGER AS $$ BEGIN
		NEW.updated_at := CURRENT_TIMESTAMP;
	RETURN NEW;
	
END;
$$ LANGUAGE plpgsql SECURITY DEFINER 
SET search_path = PUBLIC;

-- 为media_assets表添加updated_at触发器
CREATE TRIGGER trigger_media_assets_updated_at BEFORE UPDATE ON media_assets FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column ( );

-- 为tags表添加updated_at触发器
CREATE TRIGGER trigger_tags_updated_at BEFORE UPDATE ON tags FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column ( );



触发器_full_path级联更新:
-- 计算单条标签的 full_path
CREATE OR REPLACE FUNCTION tags_compute_full_path(p_name TEXT, p_parent_id UUID)
RETURNS TEXT
LANGUAGE plpgsql AS $$
DECLARE
  v_parent_path TEXT;
BEGIN
  IF p_parent_id IS NULL THEN
    RETURN p_name;
  END IF;

  SELECT full_path INTO v_parent_path
  FROM tags
  WHERE id = p_parent_id;

  RETURN v_parent_path || '/' || p_name;
END;
$$;

-- 递归级联更新子节点 full_path
CREATE OR REPLACE FUNCTION tags_cascade_update_full_path(p_id UUID)
RETURNS VOID
LANGUAGE plpgsql AS $$
DECLARE
  v_child UUID;
  v_name TEXT;
  v_parent_id UUID;
BEGIN
  -- 更新当前节点
  SELECT name, parent_id INTO v_name, v_parent_id
  FROM tags
  WHERE id = p_id;

  UPDATE tags
  SET full_path = tags_compute_full_path(v_name, v_parent_id),
      updated_at = CURRENT_TIMESTAMP
  WHERE id = p_id;

  -- 递归更新所有子节点
  FOR v_child IN
    SELECT id FROM tags WHERE parent_id = p_id
  LOOP
    PERFORM tags_cascade_update_full_path(v_child);
  END LOOP;
END;
$$;

-- BEFORE INSERT/UPDATE：先计算本节点 full_path
CREATE OR REPLACE FUNCTION tags_before_ins_upd()
RETURNS TRIGGER
LANGUAGE plpgsql AS $$
BEGIN
  NEW.full_path := tags_compute_full_path(NEW.name, NEW.parent_id);
  NEW.updated_at := CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- AFTER INSERT/UPDATE：触发级联更新子节点
CREATE OR REPLACE FUNCTION tags_after_ins_upd()
RETURNS TRIGGER
LANGUAGE plpgsql AS $$
BEGIN
  PERFORM tags_cascade_update_full_path(NEW.id);
  RETURN NULL;
END;
$$;

-- 绑定触发器
CREATE TRIGGER trg_tags_before_ins_upd
BEFORE INSERT OR UPDATE OF name, parent_id
ON tags
FOR EACH ROW
EXECUTE FUNCTION tags_before_ins_upd();

CREATE TRIGGER trg_tags_after_ins_upd
AFTER INSERT OR UPDATE OF name, parent_id
ON tags
FOR EACH ROW
EXECUTE FUNCTION tags_after_ins_upd();

触发器_media_assets表同步次数自增:
-- 1. 创建触发器函数：更新时自动自增 sync_count
CREATE OR REPLACE FUNCTION increment_sync_count()
RETURNS TRIGGER AS $$
BEGIN
    -- 只在记录被更新时执行（排除 INSERT 场景）
    IF TG_OP = 'UPDATE' THEN
        -- 将新记录的 sync_count 设置为 旧值 + 1
        NEW.sync_count = OLD.sync_count + 1;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. 创建触发器，绑定到 media_assets 表的 UPDATE 事件
CREATE TRIGGER trigger_media_assets_sync_count
BEFORE UPDATE ON media_assets
FOR EACH ROW
EXECUTE FUNCTION increment_sync_count();